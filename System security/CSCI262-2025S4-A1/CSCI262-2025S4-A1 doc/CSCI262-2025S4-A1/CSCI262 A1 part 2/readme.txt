
CSCI262 Assignment 1 — Part Two (Rainbow Table)
===============================================

Language: Python 3.x

Files
-----
- Rainbow.py      : Main program.
- Passwords.txt   : Supplied password list (one password per line).
- Rainbow.txt     : Output rainbow table (generated by the program).

How to Run
----------
1) Ensure 'Passwords.txt' is in the same directory as 'Rainbow.py'

2) Open the command prompt and input the directory of the folder with 'cd' at the front of the command and press 'enter' :(eg. cd C:\Users\user\Downloads\CSCI262 A1)

3) key in python Rainbow.py Passwords.txt 

   The program will:
   - Load the password list and print how many words it read.
   - Generate the rainbow table with chains of length 5 reductions per chain.
   - Sort by final hash and write the table to Rainbow.txt as tab-separated lines:
     <start_word> <final_hash>
   - Print how many lines were written.
   - Prompt you to enter an MD5 hash (32 hex chars) to find a pre-image.
     Type 'q' to quit.

Hash Function
-------------
We use Python's standard library:
    import hashlib
    hashlib.md5(...).hexdigest()
This is a widely-used implementation and requires no external packages.

Reduction Function (R)
----------------------
The reduction function deterministically maps a hex MD5 hash to an index in
[0, N), where N is the number of passwords in Passwords.txt. We also vary the
mapping by column to reduce collisions across chain columns.

Details:
  - Let 'hash_hex' be the 32-hex-digit MD5 value.
  - For column 'col' in {0,1,2,3,4}, we take an 8-hex-digit window of the hash
    starting at offset '(2 * col)' (modulo the available range), convert it to
    an integer, then do 'index = integer % N'.
  - We then pick the password at that index as the next chain word.

Rationale:
  - Using a sliding window tied to the column produces different reductions at
    each step of the chain, which reduces short cycles and collisions compared
    to a static slice.
  - The modulo operation naturally adapts to any size N of the password list.

Chain Construction
------------------
For each previously unused starting word W0:
  H0 = MD5(W0)
  For col=0..4 (5 iterations):
    idx = R(H_col, col)
    W_next = passwords[idx]     # mark as used
    H_next = MD5(W_next)
  Store (start=W0, final_hash=H5).

We sort all entries by final_hash to enable binary search during lookup.
We also mark reduced words as 'used' to avoid regenerating chains with the
same nodes, as allowed by the spec.

Lookup / Pre-image Search
-------------------------
To find a pre-image for a target hash T:
  1) Check whether T equals any chain's final hash. If yes, reconstruct that
     chain from its start and stop when a word hashes to T.
  2) Otherwise, do the classic forward-walk from different columns i=4..0:
       h = T
       for col in i..4:
         idx = R(h, col)
         w   = passwords[idx]
         h   = MD5(w)
     If the resulting h equals some chain's final hash, reconstruct from that
     chain's start and test along the chain until the word that hashes to T
     is found.
  3) If nothing matches after all i, report "No pre-image found — hash not
     present in rainbow table."

Notes
-----
- The program validates that input hashes are exactly 32 hex chars.
- The table format (tab-separated) is simple and easy to inspect or post-process.
